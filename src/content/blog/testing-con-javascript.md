---
title: Testing con Javascript
pubDate: 2019-09-02
updatedDate: 2024-06-01
description: "Introducci√≥n al testing con Javascript a trav√©s de ejemplos progresivos: de 0 a framework. Empieza con JavaScript. Finaliza usando Jest, un framework de testing para JavaScript"
type: blog
author: Jorge Baumann
tags:
  - Testing
  - JavaScript
ogImage: "https://baumannzone-dev-og.vercel.app/api/og?title=Testing%20con%20JavaScript&tags=JavaScript,Testing"
---

Introducci√≥n pr√°ctica a los tests con JavaScript (a trav√©s de Node.js) guiada por ejemplos progresivos: ‚Äú_de 0 a framework_‚Äù.

![Pollito con fondo rosa](../../assets/blog/testing-con-javascript/header.jpg)

> Photo by [Toni Cuenca](https://unsplash.com/@tonicuenca?ref=baumannzone.dev)

Hola de nuevo, querido developer.

Existen muchas y variadas razones por las que considero que los tests son √∫tiles e importantes.

No las vamos a mencionar ahora, pero si has le√≠do este [art√≠culo](/blog/about-testing) con anterioridad, ya sabr√°s lo importante que son los tests en el desarrollo de software en general.

Recuerda, cuando hablemos de pruebas (o tests), nos estamos refiriendo a **pruebas autom√°ticas**, entendiendo como tales el proceso de escribir c√≥digo que compruebe que nuestra aplicaci√≥n funciona correctamente.

El proceso a seguir es el siguiente: primero crearemos un fichero que contenga un par de funciones y despu√©s escribiremos unos tests que comprueben que dichas funciones se comportan correctamente.

Para que sea m√°s f√°cil, te dejo este [repositorio en GitHub](https://github.com/baumannzone/javascript-testing) con todos los ejemplos que vamos a necesitar.

El fichero que vamos a testear es el de `funcionesMatematicas.js`.

Ah√≠ est√°n las dos funciones (funci√≥n `suma` y funci√≥n `resta`) que iremos testeando de manera progresiva durante todo el art√≠culo.

```javascript
// funcionesMatematicas.js

const suma = (num1, num2) => num1 + num2;
const resta = (num1, num2) => num1 - num2;

module.exports = { suma, resta };
```

Podemos empezar. Sabemos lo que hay que hacer y tenemos c√≥digo que listo para ser testeado.

## Paso 0

¬øCu√°l es el ejemplo de test m√°s b√°sico que podemos crear? Para m√≠, ser√≠a algo como esto:

```javascript
// test0.js

const resultado = 1;
const esperado = 2;

if (resultado !== esperado) {
  throw new Error(`${resultado} es distinto de ${esperado}`);
}

console.log("¬°Todo OK! üëå");
```

Puedes ejecutar este test corriendo `node test-0.js` desde la terminal. Y ya lo tienes, ¬°tu primer test con JavaScript! üéâ

![Test 0 running](../../assets/blog/testing-con-javascript/test-0.png)
Resultado de error tras ejecutar el test-0.js

Cuando lo ejecutes, deber√≠a saltarte un error. Puedes probar a cambiar las variables `resultado` y `esperado` para dejarlas con el mismo valor.  
Esta vez, si lo ejecutas, ver√°s que el error ya no aparece, y en su lugar est√° un mensaje: `¬°Todo OK! üëå`

### Un test

B√°sicamente, esto es un test. Un valor de entrada (resultado de una operaci√≥n) que comparamos con otro valor (valor esperado).

- Si se cumple la condici√≥n, el test pasa correctamente.
- De lo contrario, el test falla y mostrar√≠a un error.

En este caso la condici√≥n es que los valores sean iguales, pero puede ser cualquier otra cosa, por ejemplo, ‚Äúmayor que‚Äù.

La parte del c√≥digo donde pone `resultado !== esperado` es lo que se conoce como **aserci√≥n** o aserto, en ingl√©s _assert_.  
Es la parte clave de nuestro test, si la aserci√≥n falla, lanzaremos un error.

### Testing

¬øAs√≠ de f√°cil? Desde luego que no, apreciado lector. La cosa se puede complicar m√°s, pero tenemos que empezar por el principio.

Aunque se pueda complicar en el futuro, probar las dos funciones de nuestro m√≥dulo `funcionesMatematicas.js` es extremadamente f√°cil, ya que son funciones puras.

### Funciones puras

Si no sabes lo que son, te interesa saber que en las funciones puras dados los mismos valores de entrada (argumentos) siempre retornan el mismo valor de salida.
Con un ejemplo lo entender√°s mejor:

```javascript
// Es funci√≥n pura
const suma = (num1, num2) => num1 + num2;
suma(2, 2); // => 4
suma(2, 2); // => 4

// No es funci√≥n pura
const tiempoMilisegundos = () => Date.now();
tiempoMilisegundos(); // => 1566762448192
tiempoMilisegundos(); // => 1566762450684
```

Ya sabemos c√≥mo testear con JavaScript y tenemos una funci√≥n pura deseosa de ser testeada. Me imagino que ya sabes cu√°l es el siguiente paso, ¬øverdad?

## Paso 1

Vamos a crear el test m√°s simple posible para nuestras funciones aritm√©ticas.

```javascript
// test-1.js

const { suma, resta } = require("./funcionesMatematicas");

let resultado, esperado;

// Probar suma ( 2 + 3 )
resultado = suma(2, 3);
esperado = 5;
if (resultado !== esperado) {
  throw new Error(`${resultado} es distinto de ${esperado}`);
}

// Probar resta ( 8 - 3 )
resultado = resta(8, 3);
esperado = 5;
if (resultado !== esperado) {
  throw new Error(`${resultado} es distinto de ${esperado}`);
}

console.log("¬°Test1 OK! üëå");
```

Ejecutamos el test desde la terminal con `node test-1.js` y podemos ver que la ejecuci√≥n ha terminado con √©xito.

![Test 1 running](../../assets/blog/testing-con-javascript/test-1.png)

Ahora probemos a _romper_ la funci√≥n `suma`. Quitamos el signo de suma (`+`) y ponemos el de resta (`-`). Al ejecutar el test de nuevo ver√°s un error parecido a este:

```yaml
~/javascript-testing/test-1.js:13

  throw new Error( \`${ resultado } es distinto de ${ esperado }\` )

  Error: -1 es distinto de 5

  at Object.<anonymous> (~/Code/javascript-testing/test-1.js:13:9)
  at Module.\_compile (internal/modules/cjs/loader.js:868:30)
  at Object.Module.\_extensions..js
  ...
```

¬øNo es genial? Hemos roto la funci√≥n `suma` y gracias a nuestro test, nos hemos dado cuenta inmediatamente. ¬°Somos developers orgullosos y felices!

Ahora podemos estar seguros de que si hacemos alg√∫n cambio que rompa la funcionalidad, nuestro test nos avisar√°.

Los **mensajes de error** son otro elemento clave de nuestras pruebas.  
Son realmente importantes, pues es lo primero que vemos cuando nuestro test falla y a menudo nos indican **qu√©** y **d√≥nde** ha fallado.  
Por lo tanto, querido developer, deber√≠amos intentar ser lo m√°s espec√≠ficos posibles a la hora de redactar los mensajes de error y de usar las aserciones correspondientes para cada caso.

## Paso 2

Node.js tiene un [m√≥dulo](https://nodejs.org/api/assert.html#assert_assert) (_assert_) para hacer aserciones. ¬°No necesitamos reinventar la rueda!

Vamos a refactorizar nuestro test haciendo uso de dicho m√≥dulo, con el m√©todo `strictEqual`. (M√°s info en la [documentaci√≥n oficial](https://nodejs.org/api/assert.html#assert_assert_strictequal_actual_expected_message))

```javascript
// test-2.js

const assert = require("assert");
const { suma, resta } = require("./funcionesMatematicas");

let resultado, esperado;

resultado = suma(2, 3);
esperado = 5;
assert.strictEqual(resultado, esperado);

resultado = resta(8, 3);
esperado = 5;
assert.strictEqual(resultado, esperado);

console.log("¬°Test2 OK! üëå");
```

Estupendo, el test sigue funcionando igual que antes, lo √∫nico que ha cambiado es el mensaje de error.

```
$ node test-2.js
assert.js:89
  throw new AssertionError(obj);
  ^
AssertionError [ERR_ASSERTION]: Expected values to be strictly equal:

-1 !== 5

    at Object.<anonymous> (/javascript-testing/test-2.js:13:8)
    ...
    at internal/main/run_main_module.js:17:11 {
  generatedMessage: true,
  code: 'ERR_ASSERTION',
  actual: -1,
  expected: 5,
  operator: 'strictEqual'
}
```

He truncado parte de la respuesta para que sea m√°s clara la informaci√≥n. Parece una respuesta m√°s completa y es decisi√≥n nuestra, como testers, elegir qu√© sistema queremos usar.

Si miramos la documentaci√≥n, podemos ver que `strictEqual` soporta 3 argumentos, sin embargo, nosotros le hemos pasado dos. El tercero nos permite personalizar el mensaje de error.

## Paso 3

Llegados a este punto, podr√≠amos empezar a crear nuestro _mini-framework_ o peque√±a _librer√≠a_ de testing.

Entra en juego otro fichero, `funcionesTesting.js`, en el cual vamos a ir agregando algunas funciones de ayuda para correr nuestras pruebas.

```javascript
// funcionesTesting.js

const esperoQue = (dato) => {
  return {
    seaIgualQue: (esperado) => {
      if (dato !== esperado) {
        throw new Error(`${dato} es distinto que ${esperado}`);
      }
    },
  };
};

module.exports = { esperoQue };
```

Vamos a reestructurar nuestros tests. En vez de usar el m√≥dulo de aserci√≥n de Node.js, vamos a utilizar la funcionalidad que acabamos de crear. Quedar√≠a algo como esto:

```javascript
// test-3.js

const { suma, resta } = require("./funcionesMatematicas");
const { esperoQue } = require("./funcionesTesting");

let resultado, esperado;

resultado = suma(2, 3);
esperado = 5;
esperoQue(resultado).seaIgualQue(esperado);

resultado = resta(8, 3);
esperado = 5;
esperoQue(resultado).seaIgualQue(esperado);

console.log("¬°Test3 OK! üëå");
```

Vamos a repetir el procedimiento que hicimos anteriormente. Rompemos la funci√≥n `suma` cambiando el `+` por el `-` y ejecutamos el test 3 con el siguiente comando `node test-3.js`.
Si todo va bien, deber√≠amos seguir viendo que el test nos alerta de que algo anda mal.

![error-3](../../assets/blog/testing-con-javascript/test-3-error.png)

¬°Fant√°stico! Podemos a√±adir algunas aserciones m√°s (como por ejemplo `seaMayorQue` o `seaMenorQue`, etc).
Las puedes ver en el fichero [funcionesTesting.js](https://github.com/baumannzone/javascript-testing/blob/master/funcionesTesting.js) del repositorio, en GitHub.

Este es un buen punto para parar y arreglar un par de problemas que llevamos arrastrando desde el principio.

Actualmente, cuando ejecutamos las pruebas y nos informan de un error, no tenemos forma de saber qu√© funcionalidad ha fallado.
Sabemos que est√° fallando la funci√≥n `suma`, pero podr√≠a ser perfectamente la funci√≥n `resta`.
Nuestro mensaje de error no es tan descriptivo como deber√≠a ser.

Asimismo, nos hemos dado cuenta de que nuestras pruebas no est√°n completamente aisladas unas de otras.

## Paso 4

Vamos a escribir una nueva funci√≥n que nos permita mantener las pruebas **aisladas** y que, en caso de fallo, nos indique **cu√°l** es la funcionalidad que est√° fallando.

```javascript
// funcionesTesting.js

const esperoQue = (dato) => {
  return {
    seaIgualQue: (esperado) => {
      if (dato !== esperado) {
        throw new Error(`${dato} es distinto que ${esperado}`);
      }
    },
  };
};

const prueba = (titulo, funcion) => {
  try {
    funcion();
    console.log(`‚úÖ  ¬∑ ${titulo}`);
  } catch (error) {
    console.error(`‚ùå  ¬∑ ${titulo}`);
    console.error(error);
  }
};

module.exports = { esperoQue, prueba };
```

Acabamos de crear la funci√≥n `prueba`, que nos va a resolver dichos problemas.
Esta funci√≥n requiere dos argumentos para ejecutarse, el t√≠tulo o nombre descriptivo del test y la funci√≥n que vamos a ejecutar, tambi√©n conocida como _callback_.
Si quieres saber m√°s sobre callbacks, te recomiendo leer [este art√≠culo](https://medium.com/@anamartinezaguilar/callbacks-en-javascript-8deeca9824b4) de Ana Mart√≠nez Aguilar.

Ahora podemos meter todo el c√≥digo de nuestro test en el callback `prueba` y darle un nombre descriptivo.
Hemos logrado aislar el c√≥digo de nuestras pruebas y, adem√°s, tenemos mensajes de error m√°s descriptivos que nos indican qu√© ha fallado.

Ejecutemos el test `test-4.js` y veamos c√≥mo queda.

![test 4](../../assets/blog/testing-con-javascript/test-4.png)

Tenemos un [listado](../../assets/blog/testing-con-javascript/test-4.mp4) de todos los tests que hemos ejecutado, los que han finalizado con √©xito y los que no.

Antes, en caso de fallo, nos aparec√≠a el mensaje de error pero no sab√≠amos de d√≥nde proven√≠a el fallo.  
Ahora, en caso de error, se nos muestra el propio error, por lo tanto sabremos exactamente qu√© es lo que tenemos que rectificar.

## Paso 5

Nuestro framework de testing va cogiendo forma.
Una buena funcionalidad a implementar ser√≠a la creaci√≥n de una interfaz de l√≠nea de comandos (_CLI_). Podr√≠amos usar [vorpal](https://vorpal.js.org/) y tratar que se encargara de buscar todas las pruebas de nuestro proyecto y que las ejecutara.

Llegados a este punto, estar√≠amos construyendo un corredor de pruebas (_test runner_) y un framework para crear nuestras pruebas.  
Pero incluso despu√©s de realizar esta funcionalidad, nos seguir√≠a quedando much√≠simo trabajo por hacer para que nuestro framework de testing estuviera listo.

Actualmente existen en el ‚Äúmercado‚Äù bastantes frameworks o librer√≠as de este tipo, mucho m√°s robustas que la nuestra. Por lo tanto, lo primero que tenemos que hacer es elegir con cu√°l queremos trabajar.

![Listado de frameworks de testing](../../assets/blog/testing-con-javascript/testing-frameworks.png)

En un principio pens√© en usar [AVA](https://github.com/avajs/ava) üöÄ, que me gusta porque es bastante simple y moderno. Sin embargo, desde mi punto de vista tiene una peque√±a deficiencia: la documentaci√≥n.
Por lo tanto, la segunda opci√≥n, sin duda alguna es [Jest](https://jestjs.io/) üÉè. En el entorno profesional es el framework de testing que m√°s utilizo y su documentaci√≥n me parece bastante buena y es m√°s intuitiva.

A d√≠a de hoy (_mayo de 2024_), si tuviera que hacer la elecci√≥n, me quedar√≠a con [Vitest](https://vitest.dev/), el framework de testing para gente cool. üòé

Por lo tanto, en vez de seguir a√±adiendo funcionalidades a nuestro framework, vamos a refactorizar nuestro c√≥digo para que funcione con Jest.

Casualmente, las funciones de Jest son muy similares a las nuestras. Lo √∫nico que tendr√≠amos que hacer es cambiar nuestras funciones `prueba` y `esperoQue` por las propias de Jest: `test` y `expect`.

```javascript
// test-5.js

const { suma, resta } = require("./funcionesMatematicas");

test("Suma 2 n√∫meros positivos correctamente", () => {
  const resultado = suma(2, 3);
  const esperado = 5;
  expect(resultado).toBe(esperado);
});

test("Resta 2 n√∫meros positivos correctamente", () => {
  const resultado = resta(8, 3);
  const esperado = 5;
  expect(resultado).toBe(esperado);
});
```

Ejecutamos nuestra quinta prueba con Jest: `npm run jest`, y si est√° todo correcto, deber√≠amos ver algo como esto:

```yaml
~/javascript-testing: npm run jest

> jest

PASS  ./test-5.js

  ‚úì Suma 2 n√∫meros positivos correctamente (3ms)
  ‚úì Resta 2 n√∫meros positivos correctamente

Test Suites: 1 passed, 1 total

Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        1.672s

Ran all test suites.
```

¬°Funciona! Como puedes observar, tester friend, el resultado que nos ofrece Jest es bastante m√°s completo que el que ten√≠amos nosotros.

Probemos ahora a romper la funci√≥n `resta` cambiando el `-` por el `+`. Ejecutemos de nuevo Jest.

![Error de jest](../../assets/blog/testing-con-javascript/error-test.png)

En esta imagen se ve mucho m√°s claro qu√© est√° fallando. Tiene colores y adem√°s nos dice qu√© y d√≥nde ha fallado junto con mucha m√°s informaci√≥n de ayuda. ¬°Bastante descriptivo!

<!-- # Las encuestas üçø

Antes de empezar a escribir este art√≠culo lanc√© en twitter un par de encuestas:

- ¬ø[Has escrito alguna vez tests para tus aplicaciones JavaScript](https://twitter.com/baumannzone/status/1165178014579273728)?

- [¬øSer√≠as capaz de testear una aplicaci√≥n JavaScript sin usar frameworks?](https://twitter.com/baumannzone/status/1165178021273395200)

Este escrito es el motivo que hay detr√°s de estas encuestas.

Si despu√©s de leer este art√≠culo tuvieras que votar... _¬øQu√© votar√≠as?_
Imagino que ahora responder√≠as "s√≠" a ambas preguntas. -->

Ahora ya sabes c√≥mo testear tus aplicaciones JavaScript de manera progresiva, desde 0 hasta llegar a un framework de testing como Jest.

Y t√∫, ¬øcon qu√© herramientas testeas tus aplicaciones JavaScript?

¬°Happy testing! üß™
